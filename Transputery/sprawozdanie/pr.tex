\documentclass[a4paper,11pt, titlepage]{article}
\usepackage[MeX]{polski}
\usepackage[]{graphicx}
\usepackage[utf8]{inputenc}% ew. utf8 lub cp1250
% Zdefiniowanie autora i~tytułu:
\title{Sprawozdanie: Testy systemu transputerowego}
\author{Szymon Francuzik Stanisław Jankowski}
\date{24 listopada 2008}
\frenchspacing
\begin{document}
% Wstawienie autora i~tytułu do składu:
\maketitle
\section{Opis zadania}
Problem polega na porównywaniu różnych sposobów przetwarzania zadań jednorodnych w systemie transputerowym. Zadaną architekturą systemu jest tu łańcuch 7 transputerów z centralnie położonym źródlem danych. Założono, iż w miarę oddalania się od źródła danych, prędkość kolejnego transputera maleje dwukrotnie w porównaniu do poprzedniego. Rozważono następujące sposoby realizacji przetwarzania:
\begin{itemize}
\item przetwarzanie szeregowe
\item przetwarzanie równoległe z jedną fazą obliczeń i jednym przesłaniem danych - 1f1p
\item przetwarzanie równoległe z jedną fazą obliczeń i dwoma przeslaniami danych - 1f2p
\item przetwarzanie równoległe z dwoma fazami obliczeń i jednym przesłaniem danych na fazę obliczeń - 2f1p
\end{itemize}
Ponadto dla każdego z podanych wariantów rozpatrzono dwa sposoby wyboru transputerów, na których realizowane są obliczenia:
\begin{itemize}
\item wybór maksymalizujący liczbę szybkich transputerów
\begin{figure}[htp!]
\includegraphics[scale=0.4]{proce}
\caption{Model maksymalizujący liczbę szybkich transputerów. \label{proce}}
\end{figure} 
\item wybór maksymalizujący liczbę szybkich łącz komunikacyjnych
\begin{figure}[htp!]
\includegraphics[scale=0.4]{lacza}
\caption{Model maksymalizujący liczbę szybkich łącz komunikacyjnych. \label{lacza}}
\end{figure} 
\end{itemize}
Wszystkie powyższe warianty rozpatrzono teoretycznie, konstruując odpowiednie problemy programowania liniowego, które pozwoliły dobrać opytmalną liczbę zadań do przetworzenia dla każdego procesora, która gwarantuje najkrótszy czas przetwarzania całej puli zadań. Aby ulożyć problemy programowania liniowego, przeprowadzono pomiary czasów komunikacji, oraz przetwarzania dla odpowiednich łącz oraz transputerów systemu.

Następnie napisano implementację wariantu z przetwarzaniem 1f1p oraz 1f2p, dla wariantu z maksymalizującegoliczbę szybkich łącz oraz dla wariantu maksymalizującego liczbę szybkich procesorow, przydzielając do każdego transputera liczbę zadań wyliczoną z modelu teoretycznego. Wyniki uzyskane z testów powyższych implementacji porównano następnie z modelami teoretycznymi.

\section{Wyznaczanie parametrow systemu}
Należało wyznaczyć czas inicjalizacji połączenia, prędkość komunikacji, oraz prędkość przetwarzania pojedynczego zadania dla badanego systemu. Uwzględniono fakt, iż czas inicjalizacji połączenia, oraz prędkość przetwarzania pojedynczego zadania, zależy od prędkości transputera - transputery w pierwszej kolumnie od lewej są szybsze niż pozostałe. Natomiast czas komunikacji zależny jest od rodzaju łącza - łącza poziome są szybsze niż pionowe.

\subsection{Pomiar czasów inicjalizacji połączenia, oraz prędkości komunikacji}
Napisano program mierzący czasy inicjalizacji polączeń, oraz prędkości przesyłania danych. Pomiary dokonano pomiędzy:
\begin{itemize}
\item dwoma szybkimi transputerami połączonymi wolnym łączem
\item dwoma wolnymi transputerami połączonymi szybkim lączem
\item dwoma wolnymi transputerami połączonymi wolnym lączem
\end{itemize}
Dokonano odpowiedniej synchronizacji procesów, aby upewnić się iż wszystkie one są zainicjowane i gotowe do przeprowadzenia pomiarów. Następnie uruchamiano funkcję ProcTime(), aby określić moment początku komunikacji i wysyłano pakiet danych do drugiego z transputerów, ktory natychmiast odsyłał otrzymane dane do nadawcy. Nadawca uruchamiał po raz drugi funkcję ProcTime(), aby określić moment końca komunikacji. Zarowno proces nadawcy jak i odbiorcy uruchamiany był z wysokim priorytetem, co gwarantowało wysoką dokładność pomiarów.

Procedurę powtarzano dla różnych wielkości pakietów z danymi. Następnie dla otrzymanych wyników obliczono regresję liniową, dzięki której otrzymano wartości czasu inicjalizacji komunikacji, oraz prędkości komunikacji. Powyższą procedurę powtarzano dla każdej z wymienionych trzech par transputerów. Oto otrzymane wyniki czasów inicjalizacji połączeń oraz przesyłania jednego pakietu danych:
\begin{table}[h!]
\begin{tabular}{|l|l|}\hline
Typ Transputera & SetupTime[$\mu$s]\\ \hline
szybki & \textbf{10,4}\\ \hline
wolny & \textbf{10,94}\\ \hline
\end{tabular}
\caption{Wyniki pomiarów czasów inicjalizacji połączeń \label{setuptime}}
\end{table}

\begin{table}[h!]
\begin{tabular}{|l|l|}\hline
Typ Łącza & Czas[$\mu$s]\\ \hline
pionowe & 4,3\textbf{10,4}\\ \hline
poziome & 2,25\textbf{10,94}\\ \hline
\end{tabular}
\caption{Wyniki pomiarów czasów inicjalizacji połączeń \label{comunication}}
\end{table}

\subsection{Pomiar prędkości przetwarzania}
Napisano program mierzący prędkość przetwarzania pojedynczego zadania na transputerze szybkim oraz wolnym. Pojedyncze zadanie polegalo na obliczeniu metodą Hornera wartości następującego wielomianu: $W(x) = (((4*x+12)*x+3)*x+3)*x+7$.

W tym celu na każdym z dwóch tranasputerów, których dotyczyły pomiary, utworzono po dwa procesy. Proces z priorytetem wolnym, na którym odbywały się obliczenia, oraz proces z priorytetem wysokim, na którym odbywały się pomiary czasu. Wybór takie sposobu pomiarów wynika z próby jak najdokładniejszego odwzorowania architektury zastosowanej przy implementacji modeli. Po odpowiedniej synchronizacji procesów, która gwarantuje ich gotowość do przeprowadzenia pomiarów, proces obliczeniowy wysyłał sygnał - liczbę całkowitą do procesu pomiarowego i zaczynał obliczenia.  Proces pomiarowy po otrzymaniu pierwszego sygnału uruchamiał funkcję ProcTime() do uzyskania czasu rozpoczęcia obliczeń. Proces obliczeniowy po zakończeniu obliczeń wysyłał do procesu mierzącego czas kolejny sygnał. Proces mierzący, po odebraniu drugiego sygnalu, uruchamiał funkcję ProcTime() aby uzyskać czas zakończenia obliczeń. Różnica obu czasów dała czas trwania obliczeń powiększony o czas przesyłania komunikatu między procesami (ok. 18 $\mu$s). 

Procedurę powtarzano dla różnej liczby zadań do przetworzenia przez procesor, przy czym dla każdej liczby zadań pomiar przeprowadzano dwudziestokrotnie. Następnie dla otrzymanych wyników obliczono regresję liniową, dzięki ktorej otrzymano wartości prędkości obliczeń dla transputera szybkiego oraz wolnego. Oto torzymane wyniki prędkości przetwarzania pojedynczego zadania:
\begin{table}[h!]
\begin{tabular}{|l|l|}\hline
Typ Transputera & Czas[$\mu$s]\\ \hline
szybki & \textbf{6,6}\\ \hline
wolny & \textbf{6,83}\\ \hline
\end{tabular}
\caption{Wyniki pomiarów prędkości przetwarzania pojedynczego zadania \label{speedtest}}
\end{table}

\section{Opis modeli systemów}
Dla każdego wariantu realizacji obliczeń opisanego w punkcjie pierwszym, utworzono model matemetyczny. Jest nim zadanie programowania liniowego, które następnie rozwiązywano za pomocą programu lp solve. Pozwoliło to uzyskać optymalne rozkłady puli zadań na poszczególne procesory, minimalizując tym samym czasy zakończenia obliczeń.

\begin{itemize}
\item \textbf{v} - całkowita liczba zadań do realizacji przez system
\item \textbf{T} - minimalizowany całkowity czas przetwarzania v zadań
\item \textbf{li} - liczba zadań dla itego procesora, i=1..7
\item \textbf{li} - czas przetwarzania pojedynczego zadania na itym transputerze, i=1..7
\item \textbf{s1, s2} - czas inicjalizacji komunikacji, odpowiednio dla szybkiego i wolnego transputera
\item \textbf{s1, s2} - czas przesłu jednego pakietu danych, odpowiednio wolnym i szybkim łączem
\end{itemize}
\textbf{Uwaga!
\begin{itemize}
\item Poniżej przedstawiono tylko równania i/lub ograniczenia dla wybranych modeli, bez inicjalizowania zmiennych i stałych problemu. Kompletne kody dla każdego problemu umieszczone zostały na dołączonej plycie CD. 
\item Przyjęte oznaczenia (indeksy według rysunków z rozdziału Opis zadania)
\end{itemize}
}
\subsection{Model szeregowy}
W modelu tym założono iż komunikacja między transputerami przebiega szeregowo,  to znaczy transputer - źródło przesyła dane najpierw do jednego końca łańcucha a następnie do drugiego. Dopiero po zakończeniu przesyłania danych, transputer zaczyna obliczenia. Oto problemy liniowe dla omawianego modelu, przy przyjętych oznaczeniach.(rysunek!!!)

\subsubsection{Maksymalizacja liczby szybkich procesorów}
\begin{flushleft}

minimize obj: +T;\linebreak
\linebreak
R1: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l2+l3+l4)*c1 + l1*a1;\linebreak
R2: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c1 + l2*a2;\linebreak
R3: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c1 + s1+(l4)*c2 + l3*a3;\linebreak
R4: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c1 + s1+(l4)*c2 + l4*a4;\linebreak
R5: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l6+l7)*c2 + l5*a5;\linebreak
R6: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l6+l7)*c2 + s2+(l7)*c2 + l6*a6;\linebreak
R7: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l6+l7)*c2 + s2+(l7)*c2 + l7*a7;\linebreak
R8: v $=$ l1+l2+l3+l4+l5+l6+l7;\linebreak
\end{flushleft}

Rozwiązanie problemu programowania liniowego dla tego wariantu:(tabelka!!!)

\subsubsection{Maksymalizacja liczby szybkich łączy}
\begin{flushleft}

minimize obj: +T;\linebreak
\linebreak
R1: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l2+l3+l4)*c1 + l1*a1;\linebreak
R2: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c2 + l2*a2;\linebreak
R3: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c2 + s2+(l4)*c2 + l3*a3;\linebreak
R4: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c2 + s2+(l4)*c2 + l4*a4;\linebreak
R5: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l6+l7)*c2 + l5*a5;\linebreak
R6: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l6+l7)*c2 + s2+(l7)*c2 + l6*a6;\linebreak
R7: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l6+l7)*c2 + s2+(l7)*c2 + l7*a7;\linebreak
R8: v = l1+l2+l3+l4+l5+l6+l7;\linebreak
\end{flushleft}

Rozwiązanie problemu programowania liniowego dla tego wariantu:(tabelka!!!)

\subsection{Model 1f1p}
W modelu tym założono, że komunikacja i obliczenia na każdym transputerze przebiega równolegle. Ponadto dla transputera - źródła, komunikacja przebiega równolegle do obu końców łańcucha. Oto problemy liniowe dla omawianego modelu, przy przyjętych oznaczeniach.(rysunek!!!)

\subsubsection{Maksymalizacja liczby szybkich procesorów}
\begin{flushleft}
minimize obj: +T;\linebreak
\linebreak
R1: T $>=$ l1*a1;\linebreak
R2: T $>=$ s1+(l2+l3+l4)*c1 +l2*a2;\linebreak
R3: T $>=$ s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c1 + l3*a3;\linebreak
R4: T $>=$ s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c1 + s1+(l4)*c2 +l4*a4;\linebreak
R5: T $>=$ s1+(l5+l6+l7)*c1 + l5*a5;\linebreak
R6: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l5+l6)*c2 + l6*a6;\linebreak
R7: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l5+l6)*c2 +  s2+(l6)*c2 + l7*a7;\linebreak
R8: v = l1+l2+l3+l4+l5+l6+l7;\linebreak
\end{flushleft}

Rozwiązanie problemu programowania liniowego dla tego wariantu:(tabelka!!!)

\subsubsection{Maksymalizacja liczby szybkich łączy}
\begin{flushleft}

minimize obj: +T;\linebreak
\linebreak
R1: T $>=$ l1*a1;\linebreak
R2: T $>=$ s1+(l2+l3+l4)*c1 + l2*a2;\linebreak
R3: T $>=$ s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c2 + l3*a3;\linebreak
R4: T $>=$ s1+(l2+l3+l4)*c1 + s1+(l3+l4)*c2 + s2+(l4)*c2 +l4*a4;\linebreak
R5: T $>=$ s1+(l5+l6+l7)*c1 + l5*a5;\linebreak
R6: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l5+l6)*c2 + l6*a6;\linebreak
R7: T $>=$ s1+(l5+l6+l7)*c1 + s1+(l5+l6)*c2 +  s2+(l6)*c2 + l7*a7;\linebreak
R8: v = l1+l2+l3+l4+l5+l6+l7;\linebreak
\end{flushleft}

Rozwiązanie problemu programowania liniowego dla tego wariantu:(tabelka!!!)

\subsection{Model 1f2p}
W modelu tym założono, że komunikacja odbywa się w dwóch etapach. W pierwszym etapie komunikacji, transputer odbiorca otrzymuje dane potrzebne mu do całkowitej realizacji swojej części obliczeń. W drugim etapie komunikacji otrzymuje natomiast dane do przesłania kolejnym transputerom w łańcuchu. Proces obliczeń i komunikacji został zrównoleglony w maksymalnym możliwym stopniu. Oto problemy liniowe dla omawianego modelu, przy przyjętych oznaczeniach.(rysunek!!!)

\subsubsection{Maksymalizacja liczby szybkich procesorów}
\begin{flushleft}

minimize obj: +T;\linebreak
\linebreak
R1: T $>=$ l1*a1;\linebreak
R2: T $>=$ s1+(l2)*c1 + l2*a2;\linebreak
R3: T $>=$ s1+(l2)*c1 + s1+(l3+l4)*c1 + s1+(l3)*c1 + l3*a3;\linebreak
R4: T $>=$ s1+(l2)*c1 + s1+(l3+l4)*c1 + s1+(l3)*c1 + s1+(l4)*c1 + s1+(l4)*c2 + l4*a4;\linebreak
R5: T $>=$ s1+(l5)*c1 + l5*a5;\linebreak
R6: T $>=$ s1+(l5)*c1 + s1+(l6+l7)*c1 + s1+(l6)*c2 + l6*a6;\linebreak
R7: T $>=$ s1+(l5)*c1 + s1+(l6+l7)*c1 + s1+(l6)*c2 + s1*(l7)*c2 + s2*(l7)*c2 +l7*a7;\linebreak
R8: v = l1+l2+l3+l4+l5+l6+l7;\linebreak
\end{flushleft}

Rozwiązanie problemu programowania liniowego dla tego wariantu:(tabelka!!!)

\subsubsection{Maksymalizacja liczby szybkich łączy}
\begin{flushleft}

minimize obj: +T;\linebreak
\linebreak
R1: T $>=4$ l1*a1;\linebreak
R2: T $>=$ s1+(l2)*c1 + l2*a2;\linebreak
R3: T $>=$ s1+(l2)*c1 + s1+(l3+l4)*c1 + s1+(l3)*c2 + l3*a3;\linebreak
R4: T $>=$ s1+(l2)*c1 + s1+(l3+l4)*c1 + s1+(l3)*c2 + s1+(l4)*c2 + s2+(l4)*c2 + l4*a4;\linebreak
R5: T $>=$ s1+(l5)*c1 + l5*a5;\linebreak
R6: T $>=$ s1+(l5)*c1 + s1+(l6+l7)*c1 + s1+(l6)*c2 + l6*a6;\linebreak
R7: T $>=$ s1+(l5)*c1 + s1+(l6+l7)*c1 + s1+(l6)*c2 + s1*(l7)*c2 + s2*(l7)*c2 + l7*a7;\linebreak
R8: v = l1+l2+l3+l4+l5+l6+l7;\linebreak
\end{flushleft}

Rozwiązanie problemu programowania liniowego dla tego wariantu:(tabelka!!!)

\subsection{Model 2f1p}
W modelu tym komunikację między transputerami rozbito na dwie fazy. W pierwszej komunikacji fazie każdy z transputerów otrzymuje tylko częśc potrzebnych mu do obliczeń danych i może wykonać pierwszę fazę obliczeń. Natomiast w drugiej fazie komunikacji każdy z transputerów otrzymiuje drugą część potrzebnych mu do obliczeń danych i moze realizować drugą fazę obliczeń. Przesyłanie i obliczenia realizowane sę w maksymalnie zrównoleglony sposob. 
Do opisu powyższego modelu niezbędne bylo wprowadzenie nowych parametrów opisujących system:
\begin{itemize}
\item \textbf{ob}ij - Początek obliczeń na itym transputerze w jotej fazie, i=1..7, j=1..2, wyjątek dla pierwszego transputera - ob1
\item \textbf{oe}ij - Początek obliczeń na itym transputerze w jotej fazie, i=1..7, j=1..2, wyjątek dla pierwszego transputera - oe1
\item \textbf{kb}ij - Początek komunikacji na itym transputerze w jotej fazie, i=1..6, j=1..2, wyjątek dla pierwszego transputera - kbijk, gdzie k oznacza: g - komunikację w stronę węzła 7, d - w stronę węzła 4
\item \textbf{ke}ij - Początek komunikacji na itym transputerze w jotej fazie, i=1..6, j=1..2, wyjątek dla pierwszego transputera - keijk, gdzie k oznacza: g - komunikację w stronę węzła 7, d - w stronę węzła 4 
\end{itemize}
Oto problemy liniowe dla omawianego modelu, przy przyjętych oznaczeniach.(rysunek!!!)
\subsubsection{Maksymalizacja liczby szybkich procesorów}

\begin{flushleft}
minimize obj: T;\linebreak
\linebreak
r1: T $>=$ oe1;\linebreak
r2: T $>=$ oe22;\linebreak
r3: T $>=$ oe32;\linebreak
r4: T $>=$ oe42;\linebreak
r5: T $>=$ oe52;\linebreak
r6: T $>=$ oe62;\linebreak
r7: T $>=$ oe72;\linebreak 
\linebreak
r8: kb21 $>=$ ke11d;\linebreak
r9: kb22 $>=$ ke12d;\linebreak
r10: kb31 $>=$ ke21;\linebreak
r11: kb32 $>=$ ke22;\linebreak
r12: kb41 $>=$ ke31;\linebreak
r13: kb42 $>=$ ke32;\linebreak
r14: kb51 $>=$ ke11g;\linebreak
r15: kb52 $>=$ ke12g;\linebreak
r16: kb61 $>=$ ke51;\linebreak
r17: kb62 $>=$ ke52;\linebreak
\linebreak
r18: v = l1 + l21 + l22 + l31 + l32 + l41 + l42 + l51 + l52 + l61 + l62 + l71 + l72;\linebreak
\linebreak
r19: ke11g = kb11g + s1+(l51+l61+l71)*c1;\linebreak
r20: ke12g = kb12g + s1+(l52+l62+l72)*c1;\linebreak
r21: ke11d = kb11d + s1+(l21+l31+l41)*c1;\linebreak
r22: ke12d = kb12d + s1+(l22+l32+l42)*c1;\linebreak
r23: ke21 = kb21 + s1+(l31+l41)*c1;\linebreak
r24: ke22 = kb22 + s1+(l32+l42)*c1;\linebreak
r25: ke31 = kb31 + s1+(l41)*c2;\linebreak
r26: ke32 = kb32 + s1+(l42)*c2;\linebreak
r27: ke51 = kb51 + s1+(l61+l71)*c2;\linebreak
r28: ke52 = kb52 + s1+(l62+l72)*c2;\linebreak
r29: ke61 = kb61 + s2+(l71)*c2;\linebreak
r30: ke62 = kb62 + s2+(l72)*c2;\linebreak
\linebreak
r31: kb12g $>=$ ke11g;\linebreak
r32: kb12d $>=$ ke11d;\linebreak
r33: kb22 $>=$ ke21;\linebreak
r34: kb32 $>=$ ke31;\linebreak
r35: kb42 $>=$ ke41;\linebreak
r36: kb52 $>=$ ke51;\linebreak
r37: kb62 $>=$ ke61;\linebreak
\linebreak
r38: ob22 $>=$ oe21;\linebreak
r39: ob32 $>=$ oe31;\linebreak
r40: ob42 $>=$ oe41;\linebreak
r41: ob52 $>=$ oe51;\linebreak
r42: ob62 $>=$ oe61;\linebreak
r43: ob72 $>=$ oe71;\linebreak
\linebreak
r44: ob21 $>=$ ke11d;\linebreak
r45: ob22 $>=$ ke12d;\linebreak
r46: ob31 $>=$ ke21;\linebreak
r47: ob32 $>=$ ke22;\linebreak
r48: ob41 $>=$ ke31;\linebreak
r49: ob42 $>=$ ke32;\linebreak
r50: ob51 $>=$ ke11g;\linebreak
r51: ob52 $>=$ ke12g;\linebreak
r52: ob61 $>=$ ke51;\linebreak
r53: ob62 $>=$ ke52;\linebreak
r54: ob71 $>=$ ke61;\linebreak
r55: ob72 $>=$ ke62;\linebreak
\linebreak
r56: oe1 = ob1 + a1*l1;\linebreak
r57: oe21 = ob21 + a2*l21;\linebreak
r58: oe22 = ob22 + a2*l22;\linebreak
r59: oe31 = ob31 + a3*l31;\linebreak
r60: oe32 = ob32 + a3*l32;\linebreak
r61: oe41 = ob41 + a4*l41;\linebreak
r62: oe42 = ob42 + a4*l42;\linebreak
r63: oe51 = ob51 + a5*l51;\linebreak
r64: oe52 = ob52 + a5*l52;\linebreak
r65: oe61 = ob61 + a6*l61;\linebreak
r66: oe62 = ob62 + a6*l62;\linebreak
r67: oe71 = ob71 + a7*l71;\linebreak
r68: oe72 = ob72 + a7*l72;\linebreak
\end{flushleft}

Rozwiązanie problemu programowania liniowego dla tego wariantu:(tabelka!!!)

\subsubsection{Maksymalizacja liczby szybkich łączy}

\begin{flushleft}
minimize obj: T;\linebreak
\linebreak
r1: T $>=$ oe1;\linebreak
r2: T $>=$ oe22;\linebreak
r3: T $>=$ oe32;\linebreak
r4: T $>=$ oe42;\linebreak
r5: T $>=$ oe52;\linebreak
r6: T $>=$ oe62;\linebreak
r7: T $>=$ oe72;\linebreak
\linebreak
r8: kb21 $>=$ ke11d;\linebreak
r9: kb22 $>=$ ke12d;\linebreak
r10: kb31 $>=$ ke21;\linebreak
r11: kb32 $>=$ ke22;\linebreak
r12: kb41 $>=$ ke31;\linebreak
r13: kb42 $>=$ ke32;\linebreak
r14: kb51 $>=$ ke11g;\linebreak
r15: kb52 $>=$ ke12g;\linebreak
r16: kb61 $>=$ ke51;\linebreak
r17: kb62 $>=$ ke52;\linebreak
\linebreak
r18: v = l1 + l21 + l22 + l31 + l32 + l41 + l42 + l51 + l52 + l61 + l62 + l71 + l72;\linebreak
\linebreak
r19: ke11g = kb11g + s1+(l51+l61+l71)*c1;\linebreak
r20: ke12g = kb12g + s1+(l52+l62+l72)*c1;\linebreak
r21: ke11d = kb11d + s1+(l21+l31+l41)*c1;\linebreak
r22: ke12d = kb12d + s1+(l22+l32+l42)*c1;\linebreak
r23: ke21 = kb21 + s1+(l31+l41)*c2;\linebreak
r24: ke22 = kb22 + s1+(l32+l42)*c2;\linebreak
r25: ke31 = kb31 + s2+(l41)*c2;\linebreak
r26: ke32 = kb32 + s2+(l42)*c2;\linebreak
r27: ke51 = kb51 + s1+(l61+l71)*c2;\linebreak
r28: ke52 = kb52 + s1+(l62+l72)*c2;\linebreak
r29: ke61 = kb61 + s2+(l71)*c2;\linebreak
r30: ke62 = kb62 + s2+(l72)*c2;\linebreak
\linebreak
r31: kb12g $>=$ ke11g;\linebreak
r32: kb12d $>=$ ke11d;\linebreak
r33: kb22 $>=$ ke21;\linebreak
r34: kb32 $>=$ ke31;\linebreak
r35: kb42 $>=$ ke41;\linebreak
r36: kb52 $>=$ ke51;\linebreak
r37: kb62 $>=$ ke61;\linebreak
\linebreak
r38: ob22 $>=$ oe21;\linebreak
r39: ob32 $>=$ oe31;\linebreak
r40: ob42 $>=$ oe41;\linebreak
r41: ob52 $>=$ oe51;\linebreak
r42: ob62 $>=$ oe61;\linebreak
r43: ob72 $>=$ oe71;\linebreak
\linebreak
r44: ob21 $>=$ ke11d;\linebreak
r45: ob22 $>=$ ke12d;\linebreak
r46: ob31 $>=$ ke21;\linebreak
r47: ob32 $>=$ ke22;\linebreak
r48: ob41 $>=$ ke31;\linebreak
r49: ob42 $>=$ ke32;\linebreak
r50: ob51 $>=$ ke11g;\linebreak
r51: ob52 $>=$ ke12g;\linebreak
r52: ob61 $>=$ ke51;\linebreak
r53: ob62 $>=$ ke52;\linebreak
r54: ob71 $>=$ ke61;\linebreak
r55: ob72 $>=$ ke62;\linebreak
\linebreak
r56: oe1 = ob1 + a1*l1;\linebreak
r57: oe21 = ob21 + a2*l21;\linebreak
r58: oe22 = ob22 + a2*l22;\linebreak
r59: oe31 = ob31 + a3*l31;\linebreak
r60: oe32 = ob32 + a3*l32;\linebreak
r61: oe41 = ob41 + a4*l41;\linebreak
r62: oe42 = ob42 + a4*l42;\linebreak
r63: oe51 = ob51 + a5*l51;\linebreak
r64: oe52 = ob52 + a5*l52;\linebreak
r65: oe61 = ob61 + a6*l61;\linebreak
r66: oe62 = ob62 + a6*l62;\linebreak
r67: oe71 = ob71 + a7*l71;\linebreak
r68: oe72 = ob72 + a7*l72;\linebreak
\end{flushleft}

Rozwiązanie problemu programowania liniowego dla tego wariantu:(tabelka!!!)

\section{Opis implementacji modeli}
Zaimplementowano programy realizujące modele 1f1p oraz 2f1p w wersjach uwzględniających architekturę zarowno dla maksymalizacji liczby szybkich procesorów jak i maksymalizacji liczby szybkich łącz - patrz opis zadania. Dla każdego transputera użytego w danej implementacji stworzono dwa procesy: obliczeniowy i pomiarowo-komunikacyjny. Proces obliczeniowy uruchamiano z priorytetem niskim. Natomiast proces pomiarowo-komunikacyjny z priorytetem wysokim.

Pierwszą fazą działania programów była synchronizacja porcesów.

\subsection{Model 1f1p}
W modelu tym mierzono trzy momenty czasowe dla każdego z transputerów. Mierzono czas bezpośrednio przed i po wyslaniu danych do kolejnego transputera
\subsection{Model 2f1p}
\section{Opis wyników testów implementacji dla wybranych modeli}
\subsection{Model 1f1p}
\subsubsection{Maksymalizacja liczby szybkich procesorów}
\subsubsection{Maksymalizacja liczby szybkich łączy}
\subsection{Model 1f2p}
\subsubsection{Maksymalizacja liczby szybkich procesorów}
\subsubsection{Maksymalizacja liczby szybkich łączy}
\section{Porównanie wyników implementacji z wynikami uzyskanymi dla modelu teoretycznego}
\section{Wnioski}
\end{document}